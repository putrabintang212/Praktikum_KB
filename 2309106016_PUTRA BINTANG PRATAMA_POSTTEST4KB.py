# -*- coding: utf-8 -*-
"""Posttest

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_oi0iNjMjhKX8qN3omUCBxZQZj1EgsIF
"""

import pandas as pd

df = pd.read_csv('Strava-Running-Data.csv')

"""Hitung dan tampilkan rata-rata, standar deviasi, nilai minimum, nilai maksimum, Q1, Q2, dan Q3 untuk atribut bertipe angka.

"""

numeric_df = df.select_dtypes(include=['number'])
display(numeric_df.describe())

"""Tampilkan 10 baris pertama dari DataFrame yang hanya berisi atribut bertipe angka.

"""

display(numeric_df.head(10))

"""
Tampilkan informasi jumlah record, jumlah attribute total, nama semua attribute, dan jumlah attribute bertipe angka.
"""

num_records, total_attributes = df.shape
attribute_names = df.columns.tolist()
num_numeric_attributes = df.select_dtypes(include=['number']).shape[1]

print(f"Jumlah record: {num_records}")
print(f"Jumlah attribute total: {total_attributes}")
print("Nama semua attribute:")
for name in attribute_names:
    print(f"- {name}")
print(f"Jumlah attribute bertipe angka: {num_numeric_attributes}")

"""Tampilkan jumlah label dari semua attribute yang bernilai object

"""

object_cols = df.select_dtypes(include=['object']).columns
print("Jumlah label (nilai unik) untuk setiap attribute bertipe object:")
for col in object_cols:
    num_unique = df[col].nunique()
    print(f"- {col}: {num_unique}")

"""Visualisasikan dataset dengan salah satu grafik."""

import matplotlib.pyplot as plt
import seaborn as sns

plt.figure(figsize=(10, 6))
sns.histplot(data=numeric_df, x='distance', kde=True)
plt.title('Distribution of Running Distances')
plt.xlabel('Distance (meters)')
plt.ylabel('Frequency')
plt.show()

"""Tampilkan korelasi dataset menggunakan heatmap."""

import matplotlib.pyplot as plt
import seaborn as sns

correlation_matrix = numeric_df.corr()

plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Correlation Heatmap of Numeric Attributes')
plt.show()

"""## Kesimpulan

### Subtask:
Tulis kesimpulan dari hasil analisis dan visualisasi data pada cell Markdown.

"""

# Commented out IPython magic to ensure Python compatibility.
# %%markdown
# ## Kesimpulan Analisis dan Visualisasi Data Lari Strava
# 
# Berdasarkan analisis statistik dan visualisasi data dari file "Strava-Running-Data.csv", berikut adalah beberapa temuan kunci:
# 
# **Ringkasan Statistik Data Numerik:**
# 
# Analisis statistik deskriptif pada atribut bertipe angka memberikan gambaran umum tentang karakteristik data lari. Rata-rata, standar deviasi, nilai minimum, maksimum, serta kuartil (Q1, Q2, Q3) untuk atribut seperti `distance`, `moving_time`, `elapsed_time`, `total_elevation_gain`, `average_speed`, dan `max_speed` telah dihitung. Ini memberikan pemahaman tentang sebaran dan nilai tipikal dari setiap metrik lari. Misalnya, rata-rata jarak lari memberikan indikasi umum tentang seberapa jauh lari yang biasanya dilakukan dalam dataset ini, sementara standar deviasi menunjukkan variabilitas jarak lari tersebut.
# 
# **Visualisasi Distribusi Jarak Lari (Histogram):**
# 
# Histogram dari atribut `distance` menunjukkan distribusi frekuensi jarak lari. Dari visualisasi ini, kita dapat melihat pola umum jarak lari yang paling sering dicatat dalam dataset. Puncak pada histogram menunjukkan rentang jarak lari yang paling umum, sementara ekor distribusi (jika ada) dapat menunjukkan adanya lari jarak yang lebih panjang atau lebih pendek yang jarang dilakukan. Bentuk distribusi (misalnya, simetris, miring ke kanan/kiri) juga memberikan wawasan tentang kebiasaan lari pengguna.
# 
# **Visualisasi Korelasi Antar Atribut Numerik (Heatmap):**
# 
# Heatmap korelasi antara atribut numerik mengungkapkan kekuatan dan arah hubungan linear antar variabel. Beberapa temuan kunci dari heatmap meliputi:
# 
# *   **Korelasi Positif Kuat antara `distance` dan `moving_time`:** Seperti yang diharapkan, terdapat korelasi positif yang kuat antara jarak lari (`distance`) dan waktu bergerak (`moving_time`). Ini logis, karena semakin jauh jarak yang ditempuh, semakin lama waktu yang dibutuhkan untuk menyelesaikannya.
# *   **Korelasi dengan Kecepatan:** Korelasi antara jarak (`distance`) dan kecepatan rata-rata (`average_speed`) atau kecepatan maksimum (`max_speed`) mungkin menunjukkan hubungan yang lebih kompleks. Kecepatan rata-rata cenderung memiliki korelasi positif dengan jarak, tetapi kekuatannya bisa bervariasi tergantung pada faktor lain seperti durasi dan upaya.
# *   **Korelasi Atribut Lain:** Heatmap juga menunjukkan korelasi antara atribut lain seperti `total_elevation_gain` dengan `distance` atau `moving_time`, yang dapat mengindikasikan bahwa lari dengan peningkatan elevasi yang lebih besar mungkin cenderung memiliki jarak atau durasi tertentu.
# 
# **Kesimpulan Menyeluruh:**
# 
# Dari analisis dan visualisasi data lari Strava ini, kita dapat menyimpulkan bahwa dataset ini mencakup berbagai jenis lari dengan variasi dalam jarak, durasi, dan metrik lainnya. Terdapat hubungan yang jelas dan logis antar beberapa atribut, terutama antara jarak dan waktu bergerak. Visualisasi seperti histogram dan heatmap sangat membantu dalam memahami distribusi data dan mengidentifikasi pola serta hubungan antar variabel yang mungkin tidak terlihat hanya dari ringkasan statistik. Analisis ini memberikan dasar yang kuat untuk eksplorasi lebih lanjut atau pemodelan prediktif terkait performa lari.

"""#POSTTEST4

## Data cleaning


penanganan missing value, duplicate value, dan outlier pada dataset.
"""

missing_values = df.isnull().sum()
print("Jumlah missing values per kolom:")
print(missing_values)

duplicate_rows = df[df.duplicated()]
print("\nJumlah duplicate values:", duplicate_rows.shape[0])

"""
Langkah selanjutnya adalah mengidentifikasi dan menangani outlier pada kolom numerik menggunakan metode IQR sesuai instruksi. Proses ini melibatkan perhitungan Q1, Q3, dan IQR, kemudian menentukan batas atas dan batas bawah, serta memfilter DataFrame untuk menampilkan data yang tergolong sebagai outlier.
"""

Q1 = numeric_df.quantile(0.25)
Q3 = numeric_df.quantile(0.75)
IQR = Q3 - Q1

lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

outlier_mask = (numeric_df < lower_bound) | (numeric_df > upper_bound)
outliers = numeric_df[outlier_mask].dropna(how='all')

print("\nIdentified Outliers:")
display(outliers)

"""Langkah selanjutnya adalah menangani outlier tersebut dengan menghapus baris yang mengandung outlier dari DataFrame."""

df_cleaned = df.copy()
df_cleaned = df_cleaned[~outlier_mask.any(axis=1)]

print(f"\nJumlah record setelah penanganan outlier: {df_cleaned.shape[0]}")

"""Langkah terakhir adalah memverifikasi kembali bahwa tidak ada nilai yang hilang atau duplikat baru setelah proses penghapusan outlier dilakukan."""

missing_values_cleaned = df_cleaned.isnull().sum()
print("\nJumlah missing values per kolom setelah penanganan outlier:")
print(missing_values_cleaned)

duplicate_rows_cleaned = df_cleaned[df_cleaned.duplicated()]
print("\nJumlah duplicate values setelah penanganan outlier:", duplicate_rows_cleaned.shape[0])

"""## Normalisasi/standarisasi

Penggunaan StandardScaler untuk melakukan standarisasi pada kolom numerik tersebut. Sebelum menerapkan scaler, saya memilih kolom numerik dari df_cleaned.
"""

from sklearn.preprocessing import StandardScaler

numeric_cols_cleaned = df_cleaned.select_dtypes(include=['number']).columns
scaler = StandardScaler()
df_cleaned[numeric_cols_cleaned] = scaler.fit_transform(df_cleaned[numeric_cols_cleaned])
display(df_cleaned.head())

"""## Encoding

Mengidentifikasi kolom dengan tipe data objek, kemudian menerapkan one-hot encoding pada kolom tersebut, dan menampilkan beberapa baris awal (head) dari DataFrame yang telah diencode.
"""

object_cols = df_cleaned.select_dtypes(include=['object']).columns
df_encoded = pd.get_dummies(df_cleaned, columns=object_cols, drop_first=True)
display(df_encoded.head())

"""## Feature engineering

Menghitung pace (kecepatan rata-rata) dalam menit per kilometer, kemudian menambahkannya sebagai kolom baru pada DataFrame.
"""

df_cleaned['pace_min_per_km'] = (df_cleaned['moving_time'] / 60) / (df_cleaned['distance'] / 1000)
display(df_cleaned.head())

"""## Splitting data

Melakukan import terhadap fungsi train_test_split, kemudian membagi data menjadi set pelatihan (training set) dan set pengujian (testing set).
"""

from sklearn.model_selection import train_test_split

X = df_cleaned.drop('pace_min_per_km', axis=1)
y = df_cleaned['pace_min_per_km']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

print("Shape of X_train:", X_train.shape)
print("Shape of X_test:", X_test.shape)
print("Shape of y_train:", y_train.shape)
print("Shape of y_test:", y_test.shape)

"""Ringkasan: Temuan Utama Analisis Data

Pada awalnya, dataset tidak memiliki nilai yang hilang maupun baris duplikat.

Outlier berhasil diidentifikasi pada beberapa kolom numerik menggunakan metode IQR dan kemudian dihapus, sehingga jumlah data berkurang dari 105 menjadi 57.

Setelah penghapusan outlier, dataset tetap bebas dari nilai hilang dan duplikasi.

Kolom numerik telah berhasil distandarkan menggunakan StandardScaler.

Kolom kategorikal telah berhasil diubah menjadi bentuk one-hot encoding menggunakan pd.get_dummies, dengan kategori pertama dihapus untuk mencegah multikolinearitas.

Fitur baru bernama 'pace_min_per_km' telah dibuat dengan menghitung kecepatan rata-rata (pace) dalam menit per kilometer berdasarkan kolom moving_time dan distance.

Dataset yang telah diproses kemudian dibagi menjadi data pelatihan (80%) dan data pengujian (20%), dengan hasil bentuk (shape) data pelatihan fitur (45, 19), data pengujian fitur (12, 19), target pelatihan (45,), dan target pengujian (12,).

# POSTTEST 4

## Melatih model linear regression
"""

from sklearn.linear_model import LinearRegression

linear_model = LinearRegression()
linear_model.fit(X_train, y_train)

"""## Evaluasi model linear regression

"""

from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
import numpy as np

y_pred_linear = linear_model.predict(X_test)

mae_linear = mean_absolute_error(y_test, y_pred_linear)
mse_linear = mean_squared_error(y_test, y_pred_linear)
rmse_linear = np.sqrt(mse_linear)
r2_linear = r2_score(y_test, y_pred_linear)

print(f"Linear Regression MAE: {mae_linear}")
print(f"Linear Regression MSE: {mse_linear}")
print(f"Linear Regression RMSE: {rmse_linear}")
print(f"Linear Regression R2-Score: {r2_linear}")

"""## Melatih model support vector regressor

"""

from sklearn.svm import SVR

svr_model = SVR()
svr_model.fit(X_train, y_train)

"""## Evaluasi model support vector regressor

"""

y_pred_svr = svr_model.predict(X_test)

mae_svr = mean_absolute_error(y_test, y_pred_svr)
mse_svr = mean_squared_error(y_test, y_pred_svr)
rmse_svr = np.sqrt(mse_svr)
r2_svr = r2_score(y_test, y_pred_svr)

print(f"Support Vector Regressor MAE: {mae_svr}")
print(f"Support Vector Regressor MSE: {mse_svr}")
print(f"Support Vector Regressor RMSE: {rmse_svr}")
print(f"Support Vector Regressor R2-Score: {r2_svr}")

"""## Visualisasi hasil prediksi

"""

import matplotlib.pyplot as plt

# Scatter plot for Linear Regression predictions
plt.figure(figsize=(10, 5))
plt.subplot(1, 2, 1)
plt.scatter(y_test, y_pred_linear, alpha=0.5)
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'k--', lw=2) # Diagonal line
plt.xlabel("Actual Pace (min/km)")
plt.ylabel("Predicted Pace (min/km)")
plt.title("Linear Regression: Actual vs. Predicted Pace")
plt.grid(True)

# Scatter plot for Support Vector Regressor predictions
plt.subplot(1, 2, 2)
plt.scatter(y_test, y_pred_svr, alpha=0.5, color='red')
plt.plot([y_test.min(), y_test.max()], [y_test.min(), y_test.max()], 'k--', lw=2) # Diagonal line
plt.xlabel("Actual Pace (min/km)")
plt.ylabel("Predicted Pace (min/km)")
plt.title("Support Vector Regressor: Actual vs. Predicted Pace")
plt.grid(True)

plt.tight_layout()
plt.show()

"""## Penjelasan hasil

"""

# Commented out IPython magic to ensure Python compatibility.
# %%markdown
# ## Penjelasan Mendalam tentang Hasil Evaluasi dan Visualisasi Model Regresi
# 
# Setelah melatih dan mengevaluasi model Linear Regression dan Support Vector Regressor (SVR) untuk memprediksi `pace_min_per_km`, berikut adalah analisis mendalam dari hasil metrik evaluasi dan visualisasi:
# 
# ### 1. Perbandingan Metrik Evaluasi
# 
# | Metrik       | Linear Regression | Support Vector Regressor |
# |--------------|-------------------|--------------------------|
# | MAE          | {mae_linear:.4f}  | {mae_svr:.4f}            |
# | MSE          | {mse_linear:.4f}  | {mse_svr:.4f}            |
# | RMSE         | {rmse_linear:.4f} | {rmse_svr:.4f}           |
# | R2-Score     | {r2_linear:.4f}   | {r2_svr:.4f}             |
# 
# *   **MAE (Mean Absolute Error):** MAE mengukur rata-rata magnitude error dalam satu set prediksi, tanpa mempertimbangkan arahnya. Nilai MAE yang lebih kecil menunjukkan model yang lebih baik. Dalam kasus ini, SVR memiliki MAE yang jauh lebih rendah ({mae_svr:.4f}) dibandingkan Linear Regression ({mae_linear:.4f}). Ini berarti, rata-rata, prediksi SVR lebih dekat ke nilai aktual dibandingkan Linear Regression. MAE adalah metrik yang baik untuk digunakan ketika semua error memiliki dampak yang sama.
# *   **MSE (Mean Squared Error):** MSE mengukur rata-rata dari kuadrat error. Karena error dikuadratkan, MSE memberikan bobot yang lebih besar pada error yang lebih besar. Nilai MSE yang lebih kecil menunjukkan model yang lebih baik. SVR menunjukkan MSE yang jauh lebih rendah ({mse_svr:.4f}) dibandingkan Linear Regression ({mse_linear:.4f}). Ini menegaskan bahwa SVR memiliki error prediksi yang lebih kecil secara keseluruhan, terutama dalam menangani error yang lebih besar.
# *   **RMSE (Root Mean Squared Error):** RMSE adalah akar kuadrat dari MSE. Metrik ini mengukur standar deviasi dari error prediksi. RMSE memiliki unit yang sama dengan target variabel, membuatnya lebih mudah diinterpretasikan dibandingkan MSE. SVR memiliki RMSE yang jauh lebih rendah ({rmse_svr:.4f}) dibandingkan Linear Regression ({rmse_linear:.4f}). Ini menunjukkan bahwa sebaran error prediksi SVR lebih kecil dibandingkan Linear Regression. Seperti MSE, RMSE memberikan bobot lebih pada error besar.
# *   **R2-Score:** R2-Score mengukur proporsi varian dalam target variabel yang dapat diprediksi dari fitur independen. Nilai R2-Score berkisar antara 0 hingga 1, di mana 1 menunjukkan prediksi sempurna. Nilai negatif menunjukkan bahwa model berkinerja lebih buruk daripada hanya memprediksi rata-rata nilai target. Kedua model menghasilkan R2-Score negatif (Linear Regression: {r2_linear:.4f}, SVR: {r2_svr:.4f}). Namun, R2-Score SVR yang lebih mendekati nol (meskipun masih negatif) menunjukkan bahwa SVR sedikit lebih baik dalam menjelaskan varian target dibandingkan Linear Regression yang memiliki R2-Score sangat negatif. R2-Score negatif pada Linear Regression sangat mengkhawatirkan dan mengindikasikan model tersebut sama sekali tidak cocok untuk data ini.
# 
# Berdasarkan semua metrik evaluasi, **Support Vector Regressor (SVR)** menunjukkan kinerja yang secara signifikan lebih baik dalam memprediksi `pace_min_per_km` dibandingkan Linear Regression pada dataset ini. Metrik error (MAE, MSE, RMSE) SVR jauh lebih rendah, dan meskipun R2-Score-nya masih negatif, itu menunjukkan kinerja yang sedikit kurang buruk dibandingkan Linear Regression.
# 
# ### 2. Penjelasan Visualisasi Scatter Plot
# 
# Visualisasi scatter plot dari nilai aktual vs. nilai prediksi memberikan gambaran intuitif tentang kinerja model:
# 
# *   **Linear Regression Scatter Plot:** Pada plot Linear Regression, titik-titik prediksi (`y_pred_linear`) tersebar sangat luas dan tampaknya tidak mengikuti garis diagonal (garis prediksi sempurna) dengan erat. Banyak titik yang jauh dari garis ini, baik di atas maupun di bawahnya. Sebaran yang luas ini, terutama pada nilai-nilai `pace_min_per_km` yang lebih tinggi, secara visual mengkonfirmasi metrik evaluasi yang buruk (MAE, MSE, RMSE yang tinggi dan R2-Score negatif). Ini menunjukkan bahwa model Linear Regression kesulitan menangkap pola dalam data untuk memprediksi `pace_min_per_km` secara akurat.
# *   **Support Vector Regressor Scatter Plot:** Pada plot SVR, meskipun titik-titik prediksi (`y_pred_svr`) masih menunjukkan beberapa sebaran, mereka tampak lebih terkonsentrasi di sekitar garis diagonal dibandingkan dengan Linear Regression. Sebaran ini lebih rapat, terutama di sekitar nilai-nilai `pace_min_per_km` yang lebih rendah hingga menengah. Meskipun masih ada beberapa titik yang agak jauh, secara keseluruhan, titik-titik tersebut lebih dekat ke garis prediksi sempurna. Visualisasi ini sejalan dengan metrik evaluasi yang lebih baik untuk SVR (MAE, MSE, RMSE yang lebih rendah).
# 
# Sebaran titik-titik prediksi relatif terhadap garis diagonal menunjukkan tingkat akurasi model. Semakin dekat titik-titik ke garis diagonal, semakin akurat prediksi model. Dalam hal ini, SVR menunjukkan sebaran yang lebih baik (lebih dekat ke garis diagonal), yang mengindikasikan kinerja prediksi yang lebih unggul.
# 
# ### 3. Sintesis Temuan
# 
# Sintesis dari metrik evaluasi dan visualisasi dengan jelas menunjukkan bahwa **Support Vector Regressor (SVR)** adalah model yang berkinerja lebih baik dalam memprediksi `pace_min_per_km` pada dataset yang telah dibersihkan dan dinormalisasi ini.
# 
# *   Metrik error SVR (MAE, MSE, RMSE) secara substansial lebih rendah, menunjukkan bahwa SVR menghasilkan prediksi yang rata-rata lebih dekat ke nilai aktual dan memiliki error yang lebih kecil secara keseluruhan.
# *   Meskipun kedua model memiliki R2-Score negatif, R2-Score SVR yang kurang negatif mengindikasikan bahwa model ini setidaknya sedikit lebih baik daripada hanya memprediksi rata-rata, sementara Linear Regression berkinerja jauh lebih buruk daripada baseline sederhana ini.
# *   Visualisasi scatter plot secara visual mendukung temuan metrik. Titik-titik prediksi SVR lebih terkonsentrasi di sekitar garis prediksi sempurna, menunjukkan pola prediksi yang lebih baik dibandingkan sebaran luas dari prediksi Linear Regression.
# 
# ### 4. Potensi Alasan Perbedaan Kinerja
# 
# Beberapa potensi alasan mengapa SVR berkinerja lebih baik daripada Linear Regression pada dataset ini meliputi:
# 
# *   **Non-linearitas Data:** Linear Regression mengasumsikan hubungan linear antara fitur dan target variabel. Jika hubungan antara fitur dan `pace_min_per_km` bersifat non-linear, Linear Regression akan kesulitan menangkap pola ini, menghasilkan kinerja yang buruk. SVR, terutama dengan penggunaan kernel non-linear (kernel default RBF dalam `sklearn.svm.SVR` memungkinkan ini), dapat menangani hubungan non-linear dalam data dengan lebih efektif.
# *   **Sensitivitas terhadap Outlier (Meskipun Sudah Ditangani):** Meskipun outlier telah dihapus, mungkin masih ada beberapa titik data yang, meskipun tidak terdeteksi oleh metode IQR, tetap mempengaruhi model Linear Regression yang sensitif terhadap titik-titik ekstrem. SVR, dengan konsep *epsilon-insensitive tube*, kurang sensitif terhadap outlier dalam margin tertentu, yang mungkin membantunya berkinerja lebih baik.
# *   **Struktur Dataset:** Dataset mungkin memiliki struktur atau interaksi fitur yang lebih kompleks yang tidak dapat dimodelkan secara efektif oleh model linear sederhana. SVR, dengan kemampuannya untuk bekerja di ruang berdimensi tinggi melalui fungsi kernel, mungkin lebih mampu menangkap kompleksitas ini.
# *   **Jumlah Data yang Lebih Sedikit Setelah Pembersihan:** Setelah penghapusan outlier, jumlah record berkurang menjadi 57. Dengan jumlah data yang relatif kecil, model Linear Regression mungkin lebih rentan terhadap variasi dalam data pelatihan. SVR, dengan fokusnya pada *support vectors* di dekat batas keputusan (atau dalam kasus regresi, margin), mungkin lebih stabil dalam situasi ini.
# 
# Namun, perlu dicatat bahwa R2-Score negatif untuk kedua model menunjukkan bahwa bahkan SVR dengan pengaturan default mungkin belum menjadi model yang optimal untuk memprediksi `pace_min_per_km` pada dataset ini. Penyesuaian hyperparameter SVR atau eksplorasi model regresi lain yang lebih canggih mungkin diperlukan untuk mencapai kinerja prediksi yang lebih baik.